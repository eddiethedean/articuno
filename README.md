# Articuno

**Articuno** is a Python package that bridges Polars DataFrames and Pydantic models by dynamically inferring Pydantic schemas from Polars DataFrames. This makes it easy to validate and serialize Polars data and seamlessly integrate with FastAPI endpoints without manually coding Pydantic output models.

---

## Features

- Convert Polars DataFrames to Pydantic model instances.
- Automatically infer Pydantic models from Polars schemas, including nested structs and lists.
- Generate Python source code for Pydantic models using `datamodel-code-generator`.
- Decorator and CLI support for automated FastAPI response model generation.
- Designed to streamline your data transformation → validation → API workflow.

---

## Installation

```bash
pip install articuno
```

---

## Basic Usage

```python
import polars as pl
from articuno.convert import df_to_pydantic, infer_pydantic_model

df = pl.DataFrame({
    "name": ["Alice", "Bob"],
    "age": [30, 25],
})

# Infer a Pydantic model from the DataFrame schema
Model = infer_pydantic_model(df, model_name="Person")

# Convert DataFrame rows to Pydantic instances
models = df_to_pydantic(df, model=Model)

print(models[0])
# Person(name='Alice', age=30)
```

---

## Generating Model Source Code

```python
from articuno.codegen import generate_pydantic_class_code

code = generate_pydantic_class_code(Model, model_name="Person")
print(code)
```

This outputs the Python class source code of the inferred model, which you can write to a `.py` file.

---

## FastAPI Integration with Decorator + CLI

Articuno provides an easy way to generate FastAPI response models from Polars DataFrames **automatically**.

### Decorator

Mark your FastAPI endpoint with the `@infer_response_model` decorator, specifying:

- `name`: The Pydantic model class name to generate.
- `example_input`: Example input dictionary to call the endpoint with.
- `models_path` (optional): Path to your `models.py` file where generated models will be appended.

```python
from fastapi import FastAPI
from articuno.decorator import infer_response_model
import polars as pl

app = FastAPI()

@infer_response_model(
    name="UserModel",
    example_input={"user_id": 123},
    models_path="models.py",
)
@app.get("/user/{user_id}")
def get_user(user_id: int) -> pl.DataFrame:
    df = pl.DataFrame({"id": [user_id], "name": ["Alice"]})
    return df
```

### CLI Command

Run the CLI to:

- Call decorated endpoints with example inputs.
- Infer Pydantic models from the Polars DataFrame output.
- Append generated models to your `models.py` file **with a comment**:

  ```python
  # --- Articuno autogenerated model: UserModel ---
  ```

- Insert an import statement for the new model **after all existing imports** in your app file:

  ```python
  from models import UserModel  # autogenerated by Articuno
  ```

- Modify your FastAPI endpoint decorator to add `response_model=UserModel`.
- Remove the `@infer_response_model` decorator.

```bash
articuno bootstrap path/to/your/app.py
```

### What this achieves

This workflow automates the full cycle of:

1. Writing Polars data transformation logic.
2. Running the CLI to generate matching Pydantic models.
3. Updating your FastAPI endpoints with the generated models.

No manual schema coding required.

---

## Comparison with Patito

- **Articuno** focuses on **inferring Pydantic models from Polars DataFrames**, ideal for FastAPI output validation.
- **Patito** focuses on **validating Polars DataFrames using Pydantic models** (input validation).
- Combining both can provide seamless input validation and output modeling for Polars-based FastAPI apps.

---

## License

MIT License

---
